<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code。YuKun</title>
  
  <subtitle>亂寫亂想亂筆記</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanennnnn.github.io/"/>
  <updated>2020-08-27T09:50:16.451Z</updated>
  <id>https://yanennnnn.github.io/</id>
  
  <author>
    <name>yanennnnn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML 小知識 - 區塊元素 vs 行內元素</title>
    <link href="https://yanennnnn.github.io/20200827/undefined"/>
    <id>https://yanennnnn.github.io/20200827/undefined</id>
    <published>2020-08-27T07:35:35.000Z</published>
    <updated>2020-08-27T09:50:16.451Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/wUurW9q.png" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用那麼多次 HTML 元素卻很少去了解它屬於什麼元素，所以來記錄一下我們常見的區塊元素和行內元素</p><p>順便也能了解一些元素之間的小禁忌</p><a id="more"></a><h2 id="區塊元素-block"><a href="#區塊元素-block" class="headerlink" title="區塊元素(block)"></a>區塊元素(block)</h2><p>區塊元素（或稱區塊層級元素），可以設置 <code>width</code>、<code>height</code>，在一般默認下的區塊元素，寬度會跟隨父層寬度，故而不允許其他元素佔據其相同水平空間，對應的 <code>display</code> 為 <code>block</code>；區塊元素的矩形結構稱之為盒模型( box model )，由 <code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code>所組成</p><h3 id="區塊元素包含"><a href="#區塊元素包含" class="headerlink" title="區塊元素包含"></a>區塊元素包含</h3><ul><li>文字<ul><li>p - 段落</li><li>h1, h2, h3, h4, h5, h6 - 標題 <br></li></ul></li><li>列表 <ul><li>dl - 定義列表-清單</li><li>dt - 定義列表-項目</li><li>dd - 定義列表-描述</li><li>ol - 有排序之編號清單</li><li>ul - 未排序之項目符號清單</li><li>li - 清單中之列表項目<br></li></ul></li><li>其他區塊元素 <ul><li>address - 地址</li><li>blockquote - 塊引用</li><li>div - 區塊</li><li>menu - 菜單列表</li><li>main - 主體內容</li><li>npscript - script 的替代內容（對于不支持 script 的瀏覽器顯示此內容）</li><li>pre - 預先格式化文字</li><li>figure - 有標題的獨立內容，常使用於插圖、圖表或程式片段等，標題是放在其內的 <code>figcaption</code> 元素裡。</li><li>header - 文章標題內容</li><li>nav - 導覽</li><li>aside - 側邊欄</li><li>article - 文章內容</li><li>section - 段落</li><li>footer - 頁尾</li><li>form - 表單</li><li>fieldset - 表單群組</li><li>canvas - 定義圖形</li><li>hgroup - 群組文章標題</li><li>table - 表格</li><li>tfoot - 表格腳尾</li><li>video -嵌入媒體播放器</li><li>audio -嵌入音頻播放器<br></li></ul></li><li>空元素<ul><li>hr - 水平分隔線</li></ul></li></ul><blockquote><p>只有開始標籤而沒有結束標籤的就稱為空元素</p></blockquote><h2 id="行內元素-inline"><a href="#行內元素-inline" class="headerlink" title="行內元素(inline)"></a>行內元素(inline)</h2><p>又稱內聯元素，和其他元素都在一行上，相臨的行内元素会排列在同一行；無法設置 <code>width</code> 、 <code>height</code> ，只能靠內容撐起來，上下的 <code>padding</code> 和 <code>margin</code> 設置會無效，但左右的有效，對應的 <code>display</code> 為 <code>inline</code></p><blockquote><p>上下的 <code>padding</code>、<code>margin</code> 為 <code>padding-top</code> ,<code>padding-bottom</code>, <code>margin-top</code>, <code>margin-bottom</code></p></blockquote><h3 id="行內元素包含"><a href="#行內元素包含" class="headerlink" title="行內元素包含"></a>行內元素包含</h3><ul><li>a - 連結<br></li><li>短語元素<ul><li>abbr - 縮寫標記</li><li>acronym -首字母縮寫</li><li>b - 文字加粗</li><li>bdo - 覆蓋當前文字方向</li><li>cite - 引用文字</li><li>dfn - 定義術語/專業行話</li><li>em - 強調文字(斜體)</li><li>i - 斜體</li><li>strong - 加重文字</li><li>q - 短引用</li><li>label - input 文字標籤</li><li>samp - 標示電腦程序輸出</li><li>small - 字體變小</li><li>span - 常用行內元素，定義文字內區塊</li><li>sub - 下標</li><li>sup - 上標<br></li></ul></li><li>電腦術語元素<ul><li>code - 程式碼的片段</li><li>kbd - 定義鍵盤文字</li><li>var - 定義變量<br></li></ul></li><li>其他元素<ul><li>output - 表單輸出</li><li>select - 項目選單</li><li>textarea - 多行文本輸入框<br></li></ul></li><li>空元素<ul><li>br - 換行</li><li>img - 圖片</li><li>input - 輸入框</li></ul></li></ul><h2 id="可變元素"><a href="#可變元素" class="headerlink" title="可變元素"></a>可變元素</h2><p>可變元素為根據上下文語境決定該元素為區塊元素或者行內元素</p><h3 id="可變元素包含"><a href="#可變元素包含" class="headerlink" title="可變元素包含"></a>可變元素包含</h3><ul><li>applet - java applet</li><li>button - 按鈕</li><li>del - 刪除</li><li>iframe - 嵌入框架的應用</li><li>ins - 定義標記插入的部份</li><li>map - 圖片區塊</li><li>object - object對象</li><li>script - 嵌入或引用要執行的程式碼</li></ul><h2 id="特例規則"><a href="#特例規則" class="headerlink" title="特例規則"></a>特例規則</h2><p>基本上區塊元素可以包含行內元素和某些區塊元素，行內元素不能包含區塊元素，只能包含行內元素，但有些小特例，例如:</p><ul><li><p>a 連結幾乎都能包含，不能包含 a 連結</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//錯誤示範</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>p 段落不能包含區塊元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//錯誤示範</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>test<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>li 標籤可以包含 div 以及他的父元素 ul, ol</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>456<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>789<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>如果有區塊或者行內元素想改變元素也可以使用 CSS 的 <code>display</code>，例如 li 區塊元素改成水平的時候；或者當純只是想要水平並列但一樣想要保持是區塊的話就能使用 <code>inline-block</code> 或者 <code>flex</code>，這又是另外一種坑惹XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wUurW9q.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用那麼多次 HTML 元素卻很少去了解它屬於什麼元素，所以來記錄一下我們常見的區塊元素和行內元素&lt;/p&gt;
&lt;p&gt;順便也能了解一些元素之間的小禁忌&lt;/p&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://yanennnnn.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://yanennnnn.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>六角 - JS 實戰班心得 </title>
    <link href="https://yanennnnn.github.io/20200825/undefined"/>
    <id>https://yanennnnn.github.io/20200825/undefined</id>
    <published>2020-08-25T06:36:07.000Z</published>
    <updated>2020-08-27T05:46:29.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/ley4HZ3.png" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>當時剛把 Vue 的最終作業完成了，但是那時候覺得自己對 Vue 還不夠了解，這時候剛好六角學院了 JS 直播班，想著那不如就來參加，也可以增加自己的熟悉度</p><a id="more"></a><h2 id="第一～第八週的學習過程"><a href="#第一～第八週的學習過程" class="headerlink" title="第一～第八週的學習過程"></a>第一～第八週的學習過程</h2><h3 id="開課時的小任務"><a href="#開課時的小任務" class="headerlink" title="開課時的小任務"></a>開課時的小任務</h3><p>開課前老師有給一些 JS 觀念影片給學員，是 JS 核心觀念一些內容，因為當初有買這個課程，所以當時就想不如就當作複習，順便做了一些筆記或者修改之前的筆記，最後這些筆記讓我在實作的時候，能快速找到自己要的東西， 所以說筆記挺重要的XD</p><p>還有每日任務，其實自己做的還蠻開心的(? 看自己每天都有執行，不僅能知道哪裡還是不懂加上每天都有花一點時間做每日任務也不會讓自己跟程式脫節太久，尤其是 Vue 的 <code>emit</code> 和 <code>props</code> 上完課後，搭配每日任務又更加深我的印象，比以前自己看影片時還來的知道如何使用他們。</p><h3 id="直播課期間"><a href="#直播課期間" class="headerlink" title="直播課期間"></a>直播課期間</h3><p>到了開課，因為是直播的關係，儘管之後有影片，但覺得在直播的時候會比自己看影片會更專心；之前已經有上過 Vue 的課程，所以直播時我都是以複習來看待，發現之前不懂的地方在這次直播都蠻清楚的，有些不懂得比之前看的還明白，就像我剛剛所說的 <code>emit</code> 和 <code>props</code>。</p><p>期間每週上完都會有主線任務，以前自己做最終作業的時候都要一直看別人的，到現在慢慢的可以自己摸出一些來，尤其是週六的加碼作業講解還有助教的講解，讓我懂得如何應用，了解這段程式為什麼要這樣寫</p><h2 id="結論分享"><a href="#結論分享" class="headerlink" title="結論分享"></a>結論分享</h2><p>我覺得直播班其實可以入手，雖然比自己購買課程會比較貴，但因為是直播，會有時間的壓力，可以讓你的懶癌減少一點，而且若你很急的要趕快有個作品的話，很推薦參加。如果說金錢允許的話我建議可以一起購買課程，我是兩個地方都有，畢竟當下說的是這種方式解讀，但或許影音課程又會是另外一種解讀方式，加上剛剛所說有時間的關係，所以可能你還沒吸收好又要進入下一個階段了，所以這時候有買課程的話就可以在一次複習，加深印象</p><p>因為有建 Slack 可以看到大家都在努力，說不定會覺得自己不能那麼廢而上進XD，另外也把問題丟到上面，助教回覆的都蠻快的，但我覺得六角學院不管哪裡回答問題都蠻快的XD</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ley4HZ3.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;當時剛把 Vue 的最終作業完成了，但是那時候覺得自己對 Vue 還不夠了解，這時候剛好六角學院了 JS 直播班，想著那不如就來參加，也可以增加自己的熟悉度&lt;/p&gt;
    
    </summary>
    
      <category term="六角學院" scheme="https://yanennnnn.github.io/categories/%E5%85%AD%E8%A7%92%E5%AD%B8%E9%99%A2/"/>
    
    
      <category term="活動心得" scheme="https://yanennnnn.github.io/tags/%E6%B4%BB%E5%8B%95%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>JS 趴趴走 - ES6 const &amp; let</title>
    <link href="https://yanennnnn.github.io/20200801/undefined"/>
    <id>https://yanennnnn.github.io/20200801/undefined</id>
    <published>2020-08-01T07:39:26.000Z</published>
    <updated>2020-08-27T07:58:41.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/n9iFZz1.png" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>剛開始接觸 JavaScript 時，最先使用的宣告方式是 <code>var</code>，慢慢的開始學會了 ES6 的 <code>let</code> 和 <code>const</code> ，所以就來筆記一下他們的不同</p><blockquote><p>文章啟發於六角學院的 JS 學徒特訓班第三十八關</p></blockquote><a id="more"></a><h2 id="const-vs-let-vs-var"><a href="#const-vs-let-vs-var" class="headerlink" title="const vs let vs var"></a>const vs let vs var</h2><p><code>const</code> 、 <code>let</code> 以及 <code>var</code> 都是用來宣告變數，他們都是宣告變數，為什麼明明有了 <code>var</code> 還要增加 <code>const</code> 和 <code>let</code> 呢?<br>其實就是為了修正 <code>var</code> 的一些缺點</p><h3 id="作用域-汙染全域"><a href="#作用域-汙染全域" class="headerlink" title="作用域(汙染全域)"></a>作用域(汙染全域)</h3><p><code>var</code> 屬於作用域屬於<strong>函式作用域</strong>，意思就是<code>var</code> 變數的範圍在 <code>function</code> </p><blockquote><p>作用範圍(scope)又稱作用域，指的是變數或常數的定義與語句可見(被存取得到)的範圍</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>從上面例子來看，因為屬於函式作用域(function scope)，我們不能從 <code>function</code> 內拿到 <code>a</code> 值 ，也就是說只能在函式內才能使用</p><p>而 <code>const</code> 和 <code>let</code> 屬於<strong>區塊作用域</strong>，區塊如 <code>if</code>、<code>for</code>、<code>switch</code>、<code>while</code> 等等有使用區塊(<code>{ }</code>)語句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="string">'我不能來出來'</span>;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="string">'我可以拿出來'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">//我可以拿出來</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">//ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><p>以 <code>funtion</code> 一樣也是會出現錯誤，但我們使用 <code>if</code> 發現用 <code>var</code> 宣告的 <code>c</code> 是可以取到值的，而 <code>b</code> 則不行</p><p>再來我們使用「開發人員工具」輸入 <code>window</code> 去搜尋，會發現 <code>c</code> 竟然變成全域變數了，由此得知使用 <code>const</code> 和 <code>let</code> 可以確保不會污染到全域</p><h3 id="重複宣告"><a href="#重複宣告" class="headerlink" title="重複宣告"></a>重複宣告</h3><p>我們來看看以下問題答案是什麼</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//範例一</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">234</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//範例二</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//範例三</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">d = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>範例一 : <code>var</code> 是允許重複宣告的也可以重新賦值，而且即使在同一個作用域，同樣名稱的變數也允許重複宣告，所以 <code>a</code> 答案就是 234 </li><li>範例二 : <code>let</code> 與 <code>var</code> 的不同點在於不能重複宣告，所以 <code>b</code> 答案是 3 ，而 <code>c</code> 的答案則是 <code>Identifier &#39;c&#39; has already been declared</code></li><li>範例三 : <code>const</code> 則是不能重複宣告也不能重新賦值，只能用來宣告常數(在 ES6 中的定義是constant variable 固定的變數)，所以 <code>d</code> 的答案是 <code>Assignment to constant variable.</code></li></ul><h4 id="const-的特性"><a href="#const-的特性" class="headerlink" title="const 的特性"></a>const 的特性</h4><p><code>const</code>除了以上特性外，對於物件和陣列來說若只是傳參考也可以使用，另外還有一點就是必須一定要有值，對於<code>var</code> 和 <code>let</code> 宣告變數可以不賦予值，但 <code>const</code> 不賦值就會出錯</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a;   <span class="comment">//Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><p><small>其實可以這樣想你都要宣告一個變數了怎麼可能還不賦予值對吧XDD，而 const 又不能更動值，所以邏輯上 const 就一定要有值囉</small></p><blockquote><p>關於<code>const</code>使用在物件或者陣列上，參考這篇 <a href="https://yanennnnn.github.io/20200728/ckdbcf3nd0000hc7kbnvc1juz/#more">文章</a></p></blockquote><h3 id="Hoisting-變量提升"><a href="#Hoisting-變量提升" class="headerlink" title="Hoisting 變量提升"></a>Hoisting 變量提升</h3><p>使用 <code>var</code> 宣告變數時，會有一種特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>答案竟然不是 <code>a is not defined</code> 而是 <code>undefined</code>，這是因為<strong>Hoisting</strong>的關係</p><p><code>var</code>有提升，那 <code>const</code> 和 <code>let</code>呢?</p><pre><code class="javascript"><span class="built_in">console</span>.log(b);  <span class="comment">//ReferenceError: b is not defined</span><span class="keyword">let</span> b = <span class="number">123</span>;</code></pre><p>是 <code>b is not defined</code>耶，這樣說明是不是代表沒有提升囉? 哦不不不，哦不不不，我看你是 too young too simple(誤</p><p>其實是 <code>const</code> 和 <code>let</code> 也是存在變量提升的，但因為 <strong>暫時死區（Temporal Dead Zone，TDZ)</strong> 的關係，才會感覺沒有提升</p><blockquote><p><strong>TDZ</strong> : 如宣告變數前存取該變數會產生 <code>ReferenceError</code> 錯誤，這就是稱為 暫時死區 (Temporal Dead Zone)</p></blockquote><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>最後簡單整理一個表格提供參考，也可以知道何時該用什麼方法宣告</p><table><thead><tr><th align="center"></th><th align="center">var</th><th align="center">let</th><th align="center">const</th></tr></thead><tbody><tr><td align="center">作用域(範圍)</td><td align="center">函式</td><td align="center">區塊</td><td align="center">區塊</td></tr><tr><td align="center">重複宣告</td><td align="center">可</td><td align="center">不可</td><td align="center">不可</td></tr><tr><td align="center">重新賦值</td><td align="center">可</td><td align="center">可</td><td align="center">不可</td></tr><tr><td align="center">變量提升</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/n9iFZz1.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;剛開始接觸 JavaScript 時，最先使用的宣告方式是 &lt;code&gt;var&lt;/code&gt;，慢慢的開始學會了 ES6 的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; ，所以就來筆記一下他們的不同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文章啟發於六角學院的 JS 學徒特訓班第三十八關&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://yanennnnn.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JS 趴趴走 - ES6 關於 const 的宣告</title>
    <link href="https://yanennnnn.github.io/20200728/undefined"/>
    <id>https://yanennnnn.github.io/20200728/undefined</id>
    <published>2020-07-28T06:33:10.000Z</published>
    <updated>2020-08-27T07:58:40.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/n9iFZz1.png" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天的文章啟發於六角學院的Js學徒特訓班第三十七關，除了<code>var</code>宣告變數之外，我們也可以使用ES6的<code>let</code>和<code>const</code></p><a id="more"></a><h2 id="let和const宣告"><a href="#let和const宣告" class="headerlink" title="let和const宣告"></a>let和const宣告</h2><p>首先了解let和const都屬於用來宣告的，他們兩者最大差異是</p><ul><li>let: 用來宣告變數，可以被重新指定值</li><li>const: 用來宣告常數(變數)，不能重新指定值</li></ul><p>所以當我們宣告的時候，就會寫成這樣</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">'曉華'</span>;</span><br><span class="line"><span class="keyword">const</span> b=<span class="string">'小鎮'</span>;</span><br><span class="line">a=<span class="string">'小明'</span>;</span><br><span class="line">b=<span class="string">'aaa'</span>;<span class="comment">//Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>使用<code>const</code>宣告就不能改值了，會發生錯誤</p><h2 id="const宣告物件和陣列"><a href="#const宣告物件和陣列" class="headerlink" title="const宣告物件和陣列"></a>const宣告物件和陣列</h2><p>當你要宣告會改變值的時，下意識會認為那就使用let，這次我們使用const宣告物件和陣列試試看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr=[];</span><br><span class="line">arr.push(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>會發現竟然沒出錯，這是因為JS中的陣列和物件都是屬於 Pass by reference，也就是我們所說的傳址，以上述範例來說它只是把數值放在同一個記憶體的位置，沒有指向其他地方，自然就不會產生錯誤了</p><p>這點物件也是同樣的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">    a:<span class="string">'小名'</span>,</span><br><span class="line">    b:<span class="string">'曉華'</span>,</span><br><span class="line">    c:<span class="string">'小鎮'</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.a=<span class="string">'名小小'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//&#123;a: "名小小", b: "曉華", c: "小鎮"&#125;</span></span><br></pre></td></tr></table></figure><p>但要記住，一旦跟改位置，就不能使用<code>const</code>方式宣告了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2=&#123;</span><br><span class="line">    a:<span class="string">'小名'</span>,</span><br><span class="line">    b:<span class="string">'曉華'</span>,</span><br><span class="line">    c:<span class="string">'小鎮'</span></span><br><span class="line">&#125;;</span><br><span class="line">obj2=&#123;</span><br><span class="line"> a:<span class="string">'名小小'</span> </span><br><span class="line">&#125;<span class="comment">//Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>最後放個範例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'小名'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">let</span> city = <span class="string">'台北市'</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'曉華'</span>,</span><br><span class="line">  height: <span class="number">155</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myWallet = &#123;</span><br><span class="line">  money: <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">city = <span class="string">'台中市'</span>;</span><br><span class="line">person.height = <span class="number">160</span>;</span><br><span class="line">myWallet = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以看出來，用<code>const</code>宣告的值為不可更改，若使用物件更改為同一個記憶體位置可以使用<code>const</code>，若重新指向新的記憶體則依然使用<code>let</code></p><hr><h3 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h3><blockquote><p>對於 Pass by reference 可以參考以下文章</p></blockquote><p><a href="https://ithelp.ithome.com.tw/articles/10191057" target="_blank" rel="noopener">重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？</a><br><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html" target="_blank" rel="noopener">談談 JavaScript 中 by reference 和 by value 的重要觀念</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/n9iFZz1.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天的文章啟發於六角學院的Js學徒特訓班第三十七關，除了&lt;code&gt;var&lt;/code&gt;宣告變數之外，我們也可以使用ES6的&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://yanennnnn.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JS 趴趴走 - ES6 Fetch 應用</title>
    <link href="https://yanennnnn.github.io/20200727/undefined"/>
    <id>https://yanennnnn.github.io/20200727/undefined</id>
    <published>2020-07-27T09:47:04.000Z</published>
    <updated>2020-08-27T07:58:39.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/n9iFZz1.png" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近參加了六角的js學徒特訓班，剛好需要抓取遠端資料，之前有嘗試過<code>XMLHttpRequest</code>和框架<code>axios</code>，這次來試試看如果使用Fetch是要怎麼抓取資料</p><a id="more"></a><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p><code>Fetch</code>和<code>XMLHttpRequest</code>一樣都是用來存取伺服器端的資料，以往使用<code>XMLHttpRequest</code>時會發現步驟很多</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告一個XMLHttpRequest物件</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line"><span class="comment">// 定義連線方式</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'網址'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">xhr.send();</span><br><span class="line"><span class="comment">// 如果成功就執行 </span></span><br><span class="line">xhr.onload=<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(xhr.responseText); </span><br><span class="line"><span class="comment">// 失敗就 xhrError()</span></span><br><span class="line">xhr.onerror=<span class="function">(<span class="params">err</span>)=&gt;</span> <span class="built_in">console</span>.log(err);</span><br></pre></td></tr></table></figure><p>而Fetch就大大減少這些步驟，使用<code>Promise</code>的方式抓取資料，借用六角學院的api(感謝六角學院提供練習XD)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json'</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.json());</span><br><span class="line">    <span class="keyword">return</span> res.json(); <span class="comment">//透過json()方法獲取資訊</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">err</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我們返回了<code>res.json()</code>獲取資料後，此時的資料得到的是<code>promise</code>對象，而我們所要的值就在<code>PromiseValue</code>裡面</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[PromiseStatus]]</span>: <span class="string">"fulfilled"</span> //實現（fulfilled）：表示操作成功完成。</span><br><span class="line"><span class="string">[[PromiseValue]]</span>: Array(<span class="number">221</span>)</span><br></pre></td></tr></table></figure><p>在Promise的文件中，<code>[[PromiseValue]]</code>是個內部變量，外部無法得到，只能在<code>then</code>中獲取。所以需要第二次的<code>then</code>來接收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="string">'https://raw.githubusercontent.com/hexschool/hexschoolNewbieJS/master/data.json'</span>;</span><br><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> res.json(); <span class="comment">//返回的的資料會傳到下一個then</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最後記得要加上<code>catch</code>(失敗導向)</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>使用Fetch過後，真的比以往的XMLHttpRequest或jQuery AJAX來的簡潔，認為跟框架的axios有一點像；這次剛好只碰到GET，以後看有沒有機會學習到其他方法~</p><hr><h3 id="參考文獻"><a href="#參考文獻" class="headerlink" title="參考文獻"></a>參考文獻</h3><p><a href="https://ithelp.ithome.com.tw/articles/10194388" target="_blank" rel="noopener">ES6 Fetch 遠端資料方法</a><br><a href="https://www.itdaan.com/tw/36577774e82c253cffa236a9608d8aa4" target="_blank" rel="noopener">結合promise對原生fetch的兩個then用法理解</a><br><a href="https://www.oxxostudio.tw/articles/201908/js-fetch.html" target="_blank" rel="noopener">JavaScript Fetch API 使用教學</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/n9iFZz1.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近參加了六角的js學徒特訓班，剛好需要抓取遠端資料，之前有嘗試過&lt;code&gt;XMLHttpRequest&lt;/code&gt;和框架&lt;code&gt;axios&lt;/code&gt;，這次來試試看如果使用Fetch是要怎麼抓取資料&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://yanennnnn.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="https://yanennnnn.github.io/tags/ES6/"/>
    
      <category term="AJAX" scheme="https://yanennnnn.github.io/tags/AJAX/"/>
    
  </entry>
  
</feed>
